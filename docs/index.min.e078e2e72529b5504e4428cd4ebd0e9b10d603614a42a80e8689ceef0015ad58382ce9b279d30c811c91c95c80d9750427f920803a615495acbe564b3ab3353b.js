var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/F24-CSC2770/docs/prologue/schedule/",title:"CSC 2770 Schedule",description:`This is a tentative schedule and will change.
Grading details #Assessment Type Weightage Additional Information General Participation 10% Homework 30% Announced quizzes via iLearn. Programming Assignments 30% Exams 30% Class Schedule #Week Dates Topics Week 1 Aug 26-30 Course Introduction, Overview, Number Representation (Hex, Binary, 2’s Complement) Slides: Introduction Week 2 Sept 4-6 Number Representation (Hex, Binary, 2’s Complement) (No class on Sept 2) Slides: Bits and Ints Slides: Floats Week 3 Sept 9-13 Memory Organization, Memory Management Slides: Memory Management Week 4 Sept 16-20 CPU Architecture (Program Counter, Registers, Fetch-and-Execute Cycle, Multi-Core), Distributed Architectures, Process Management, Introduction to Operating Systems Slides: CPU Slides: CPU 2 Week 5 Sept 23-27 Storage Architecture Slides: Storage Week 6 Sept 30 - Oct 4 Networking Fundamentals, The Internet, Network Edge Slides: Network Slides: Network Performance Slides: Network Links Week 7 Oct 7-11 Network Protocol Layers, Service Models, Addressing Schemes Slides: Switching Slides: IP Week 8 Oct 14-16 Advanced Networks Slides: Transport Protocols Slides: DNS and HTTP Week 9 Oct 21-25 Socket Programming Slides: Socket Programming Week 10 Oct 28 - Nov 1 Asynchrony, Concurrency, Parallelism, Locality, Advanced Memory Organization: Virtual Memory, Caching and Advances in Storage: SSD, NVMe Caching Week 11 Nov 13-15 System Security Fundamentals Week 12 Nov 18-22 Introduction to Parallelism, Performance Optimization Week 13 Nov 25-29 TBD (No class on Nov 27-29) Week 14 Dec 2-4 TBD Final Exam Dec 9 Comprehensive Final Exam `,content:`This is a tentative schedule and will change.
Grading details #Assessment Type Weightage Additional Information General Participation 10% Homework 30% Announced quizzes via iLearn. Programming Assignments 30% Exams 30% Class Schedule #Week Dates Topics Week 1 Aug 26-30 Course Introduction, Overview, Number Representation (Hex, Binary, 2’s Complement) Slides: Introduction Week 2 Sept 4-6 Number Representation (Hex, Binary, 2’s Complement) (No class on Sept 2) Slides: Bits and Ints Slides: Floats Week 3 Sept 9-13 Memory Organization, Memory Management Slides: Memory Management Week 4 Sept 16-20 CPU Architecture (Program Counter, Registers, Fetch-and-Execute Cycle, Multi-Core), Distributed Architectures, Process Management, Introduction to Operating Systems Slides: CPU Slides: CPU 2 Week 5 Sept 23-27 Storage Architecture Slides: Storage Week 6 Sept 30 - Oct 4 Networking Fundamentals, The Internet, Network Edge Slides: Network Slides: Network Performance Slides: Network Links Week 7 Oct 7-11 Network Protocol Layers, Service Models, Addressing Schemes Slides: Switching Slides: IP Week 8 Oct 14-16 Advanced Networks Slides: Transport Protocols Slides: DNS and HTTP Week 9 Oct 21-25 Socket Programming Slides: Socket Programming Week 10 Oct 28 - Nov 1 Asynchrony, Concurrency, Parallelism, Locality, Advanced Memory Organization: Virtual Memory, Caching and Advances in Storage: SSD, NVMe Caching Week 11 Nov 13-15 System Security Fundamentals Week 12 Nov 18-22 Introduction to Parallelism, Performance Optimization Week 13 Nov 25-29 TBD (No class on Nov 27-29) Week 14 Dec 2-4 TBD Final Exam Dec 9 Comprehensive Final Exam `}),e.add({id:1,href:"/F24-CSC2770/docs/prologue/semester-long-project/",title:"Programming Challenge",description:`High-Level Problem Description: \u0026ldquo;Mission Control: The Ultimate Systems Challenge\u0026rdquo; #Scenario Overview:
In the year 2145, humanity has established a colony on the distant planet Epsilon 6. The colony\u0026rsquo;s survival depends on building, managing, and optimizing interconnected computer systems that handle everything from life support and resource management to defense and communication. Each team represents a different faction within the colony (e.g., Engineering, Medical, Defense), responsible for maintaining a critical subsystem.`,content:`High-Level Problem Description: \u0026ldquo;Mission Control: The Ultimate Systems Challenge\u0026rdquo; #Scenario Overview:
In the year 2145, humanity has established a colony on the distant planet Epsilon 6. The colony\u0026rsquo;s survival depends on building, managing, and optimizing interconnected computer systems that handle everything from life support and resource management to defense and communication. Each team represents a different faction within the colony (e.g., Engineering, Medical, Defense), responsible for maintaining a critical subsystem.
However, the colony faces significant challenges: limited resources, harsh environmental conditions, and potential threats from rival factions or extraterrestrial forces. The success of each faction—and the colony as a whole—depends on their ability to efficiently utilize their constrained resources to solve complex computing problems.
Objective:
Teams must complete a series of challenges that involve programming tasks in C or C++ under resource constraints. Each challenge reflects real-world computing scenarios where teams must balance efficiency, performance, and resource management. The goal is to build a robust and resilient network of systems capable of supporting the colony\u0026rsquo;s growth and defense.
Bi-Weekly Problem Descriptions #Weeks 1-2: Binary Conversion Under Pressure #Problem: The colony receives an encrypted communication from Earth in multiple number formats (decimal, binary, hexadecimal). The colony\u0026rsquo;s communication system has limited processing power and must quickly decode the message to send an urgent response. Task: Write an optimized C program to convert numbers between different formats within strict time limits. Resource Constraints: Limited CPU cycles available for conversions; the program must run within a maximum execution time of 1 second for each conversion. Outcome: Teams learn to optimize conversion algorithms for speed and efficiency, crucial for real-time data processing. #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; // Function prototypes void decimalToBinary(int decimal); void decimalToHex(int decimal); void binaryToDecimal(char *binary); void binaryToHex(char *binary); void hexToDecimal(char *hex); void hexToBinary(char *hex); // Function to print the hexadecimal number in reverse order void printHexInReverse(char hex[], int length) { printf(\u0026quot;Hexadecimal: \u0026quot;); for (int j = length - 1; j \u0026gt;= 0; j--) { printf(\u0026quot;%c\u0026quot;, hex[j]); } printf(\u0026quot;\\n\u0026quot;); } // Function to convert decimal to binary (placeholder) void decimalToBinary(int decimal) { printf(\u0026quot;Converting decimal %d to binary...\\n\u0026quot;, decimal); // Conversion logic will go here printf(\u0026quot;Binary: %s\\n\u0026quot;, binary); } // Function to convert decimal to hexadecimal (placeholder) void decimalToHex(int decimal) { printf(\u0026quot;Converting decimal %d to hexadecimal...\\n\u0026quot;, decimal); // Conversion logic will go here // Call the function to print the hexadecimal number in reverse order printHexInReverse(hex, i); } // Function to convert binary to decimal (placeholder) void binaryToDecimal(char *binary) { printf(\u0026quot;Converting binary %s to decimal...\\n\u0026quot;, binary); // Conversion logic will go here printf(\u0026quot;Decimal: %d\\n\u0026quot;, decimal); } // Function to convert binary to hexadecimal (placeholder) void binaryToHex(char *binary) { printf(\u0026quot;Converting binary %s to hexadecimal...\\n\u0026quot;, binary); // Conversion logic will go here // Call the function to print the hexadecimal number in reverse order printHexInReverse(hex, i); } // Function to convert hexadecimal to decimal (placeholder) void hexToDecimal(char *hex) { printf(\u0026quot;Converting hexadecimal %s to decimal...\\n\u0026quot;, hex); // Conversion logic will go here printf(\u0026quot;Decimal: %d\\n\u0026quot;, decimal); } // Function to convert hexadecimal to binary (placeholder) void hexToBinary(char *hex) { printf(\u0026quot;Converting hexadecimal %s to binary...\\n\u0026quot;, hex); // Conversion logic will go here printf(\u0026quot;Binary: %s\\n\u0026quot;, binary); } // Main function to handle inputs and trigger conversions int main(int argc, char *argv[]) { // Ensure correct number of arguments are provided if (argc != 3) { printf(\u0026quot;Usage: %s -[d|b|h] [number]\\n\u0026quot;, argv[0]); printf(\u0026quot;Options:\\n\u0026quot;); printf(\u0026quot;-d [decimal] Convert decimal to binary and hexadecimal\\n\u0026quot;); printf(\u0026quot;-b [binary] Convert binary to decimal and hexadecimal\\n\u0026quot;); printf(\u0026quot;-h [hexadecimal] Convert hexadecimal to decimal and binary\\n\u0026quot;); return 1; } // Extract the flag and value from arguments // Check which flag was provided and call the appropriate function } return 0; } Test Inputs 1. Empty Input Test Case 1.1: -b '' Test Case 1.2: -h '' Test Case 1.3: -d '' 2. Input Overflow Test Case 2.1: -d 99999999999999999999999999999 Test Case 2.2: -b 111111111111111111111111111111111111111111111111111111111111111111111111 3. Invalid Characters in Binary and Hexadecimal Input Test Case 3.1: -b 11012 Test Case 3.2: -h 1G3H 4. Lowercase Hexadecimal Input Test Case 4.1: -h 1a2b 5. Negative Decimal Input Test Case 5.1: -d -15 6. Non-Numeric Characters in Decimal Input Test Case 6.1: -d 123abc 7. Valid Large Binary Input Test Case 7.1: -b 00001111 8. Invalid Flag Test Case 8.1: -x 123 9. Overflow When Converting Hexadecimal to Decimal Test Case 9.1: -h FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 10. Valid Decimal to Binary and Hexadecimal Conversions Test Case 10.1: -d 255 Test Case 10.2: -d 1024 11. Valid Binary to Decimal and Hexadecimal Conversions Test Case 11.1: -b 1111 Test Case 11.2: -b 101010 12. Valid Hexadecimal to Decimal and Binary Conversions Test Case 12.1: -h FF Test Case 12.2: -h 1A Test Case 12.3: -h ABCD Weeks 3-4: Memory Mapping with Limited Space #Problem: A critical subsystem malfunction requires immediate memory reorganization. Due to a hardware failure, only a small portion of the memory is available. Teams need to allocate and manage memory efficiently to maintain subsystem operations. Task: Create a C program that allocates memory dynamically for different data types within a limited memory space (e.g., 256 bytes). Resource Constraints: Limited memory availability; the program must avoid memory fragmentation and efficiently manage space for dynamic allocations. Outcome: Teams learn effective memory management strategies, including dynamic allocation and avoiding memory leaks under constrained conditions. #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define MEMORY_SIZE 256 #define LARGE_MEMORY_SIZE (1 * 1024 * 1024) // 1 MB #define BAD_BLOCK 'X' // Simulate the memory space for our allocator static char memory[MEMORY_SIZE]; // Simulate a large memory space for testing char *large_memory = NULL; // Structure to manage memory blocks typedef struct Block { size_t size; bool free; struct Block *next; } Block; Block *freeList = (Block*)memory; // Initialize the memory manager void initializeMemory() { freeList-\u0026gt;size = MEMORY_SIZE - sizeof(Block); freeList-\u0026gt;free = true; freeList-\u0026gt;next = NULL; } // Randomly mark blocks as \u0026quot;bad\u0026quot; in the large memory void markBadBlocks(char *memory, size_t size, size_t badBlockCount) { srand(time(NULL)); for (size_t i = 0; i \u0026lt; badBlockCount; i++) { size_t randomIndex = rand() % size; memory[randomIndex] = BAD_BLOCK; // Mark as bad block } } // Skeleton function: Allocate memory dynamically, skipping bad blocks void* myMalloc(size_t size) { // STUDENTS: Implement logic to allocate memory dynamically, ensuring that you skip over bad blocks return NULL; // Placeholder return value } // Skeleton function: Free the allocated memory void myFree(void *ptr) { // STUDENTS: Implement logic to free the allocated memory } int main(int argc, char *argv[]) { if (argc != 2) { printf(\u0026quot;Usage: %s \u0026lt;size_of_allocation\u0026gt;\\n\u0026quot;, argv[0]); return 1; } // Convert the command-line argument to an integer for allocation size size_t allocationSize = atoi(argv[1]); // Initialize memory management initializeMemory(); // Allocate a large memory block (1 MB) large_memory = (char*)malloc(LARGE_MEMORY_SIZE); if (large_memory == NULL) { printf(\u0026quot;Failed to allocate large memory.\\n\u0026quot;); return 1; } // Mark some blocks as \u0026quot;bad\u0026quot; markBadBlocks(large_memory, LARGE_MEMORY_SIZE, 1000); // Mark 1000 bad blocks // Simulate memory allocation int *array = (int*)myMalloc(allocationSize * sizeof(int)); // Allocate memory for an array of integers if (array == NULL) { printf(\u0026quot;Memory allocation failed.\\n\u0026quot;); } else { // Assign values to the array and print them for (int i = 0; i \u0026lt; allocationSize; i++) { array[i] = i * i; // Assign square of index printf(\u0026quot;Array[%d] = %d\\n\u0026quot;, i, array[i]); } // Free the allocated memory myFree(array); printf(\u0026quot;Memory successfully freed.\\n\u0026quot;); } // Clean up large memory block using system's free function myFree(large_memory); return 0; } Output
./memory_manager 10 Array[0] = 0 Array[1] = 1 Array[2] = 4 Array[3] = 9 Array[4] = 16 Array[5] = 25 Array[6] = 36 Array[7] = 49 Array[8] = 64 Array[9] = 81 Memory successfully freed. Unit Tests
// Unit Test Functions void testMemoryAllocation() { // Test 1: Allocate memory for an array of size 10 int *array = (int*)myMalloc(10 * sizeof(int)); if (array != NULL) { printf(\u0026quot;Test 1 Passed: Memory allocated for an array of size 10\\n\u0026quot;); myFree(array); } else { printf(\u0026quot;Test 1 Failed: Memory allocation for array of size 10 failed.\\n\u0026quot;); } // Test 2: Try to allocate more memory than available int *largeArray = (int*)myMalloc(MEMORY_SIZE + 1); if (largeArray == NULL) { printf(\u0026quot;Test 2 Passed: Large memory block allocation failed as expected.\\n\u0026quot;); } else { printf(\u0026quot;Test 2 Failed: Large memory block should not have been allocated.\\n\u0026quot;); myFree(largeArray); } // Test 3: Allocate memory while skipping bad blocks int *testBlock = (int*)myMalloc(50 * sizeof(int)); if (testBlock != NULL) { printf(\u0026quot;Test 3 Passed: Memory allocated by skipping bad blocks.\\n\u0026quot;); myFree(testBlock); } else { printf(\u0026quot;Test 3 Failed: Memory allocation should have succeeded by skipping bad blocks.\\n\u0026quot;); } } // Run all tests void runTests() { testMemoryAllocation(); } int main(int argc, char *argv[]) { if (argc != 2) { printf(\u0026quot;Usage: %s \u0026lt;size_of_allocation\u0026gt;\\n\u0026quot;, argv[0]); return 1; } // Convert the command-line argument to an integer for allocation size size_t allocationSize = atoi(argv[1]); // Initialize memory management initializeMemory(); // Allocate a large memory block (1 MB) large_memory = (char*)malloc(LARGE_MEMORY_SIZE); if (large_memory == NULL) { printf(\u0026quot;Failed to allocate large memory.\\n\u0026quot;); return 1; } // Mark some blocks as \u0026quot;bad\u0026quot; markBadBlocks(large_memory, LARGE_MEMORY_SIZE, 1000); // Mark 1000 bad blocks // Run unit tests runTests(); // Clean up large memory block using the system free function free(large_memory); return 0; } Sample Unit Tests Output
Test 1 Passed: Memory allocated for an array of size 10 Test 2 Passed: Large memory block allocation failed as expected. Test 3 Passed: Memory allocated by skipping bad blocks. Weeks 5-6: Network Configuration with Limited Bandwidth #Problem: Communication between different sectors of the colony is disrupted due to a bandwidth limitation. Teams must optimize their network setup to ensure reliable and efficient communication with minimal bandwidth. Task: Use socket programming in C to develop a client-server application that optimizes data transmission. Constraints: Limited packet sizes (150 bytes); Teams must use UDP; Implement efficient data transmission protocols to keep track of lost packets and retransmit. Outcome: Teams learn to create data transmission methods under resource constraints, crucial for maintaining communication quality. // server.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #define PORT 8080 #define MAX_PACKET_SIZE 150 // Limit packet size to 150 bytes // Function declarations int create_server_socket(); void bind_server_socket(int server_fd, struct sockaddr_in *address); int accept_client_connection(int server_fd, struct sockaddr_in *address); void handle_client(int client_socket); void close_server_socket(int server_fd); int main() { int server_fd, client_socket; struct sockaddr_in address; server_fd = create_server_socket(); bind_server_socket(server_fd, \u0026amp;address); listen_for_connections(server_fd); while (1) { client_socket = accept_client_connection(server_fd, \u0026amp;address); handle_client(client_socket); } close_server_socket(server_fd); return 0; } // Function to create the server socket int create_server_socket() { // TODO: Implement server socket creation return 0; } // Function to bind the server socket to an address and port void bind_server_socket(int server_fd, struct sockaddr_in *address) { // TODO: Implement binding the server socket to an address } // Function to accept client connections int accept_client_connection(int server_fd, struct sockaddr_in *address) { // TODO: Implement accepting client connection // You this is where you keep state related to the client. This might be useful for retransmission. return 0; } // Function to handle communication with the client void handle_client(int client_socket) { // TODO: Implement the logic to receive and send data to the client } // Function to close the server socket void close_server_socket(int server_fd) { // TODO: Implement closing the server socket } // client.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #define PORT 8080 #define MAX_PACKET_SIZE 150 // Limit packet size to 150 bytes // Function declarations int create_client_socket(); void connect_to_server(int client_socket, struct sockaddr_in *serv_addr); void send_message(int client_socket, const char *message); void close_client_socket(int client_socket); int main() { int client_socket; struct sockaddr_in serv_addr; char *message = \u0026quot;This is an example of a very long message that will be broken into multiple 150-byte packets.\u0026quot;; client_socket = create_client_socket(); connect_to_server(client_socket, \u0026amp;serv_addr); send_message(client_socket, message); close_client_socket(client_socket); return 0; } // Function to create the client socket int create_client_socket() { // TODO: Implement client socket creation return 0; } // Function to connect the client to the server void connect_to_server(int client_socket, struct sockaddr_in *serv_addr) { // TODO: Implement connecting the client to the server // You can emulate TCP behavior here. For now simply print which server you are connecting to. // More advanced clients will need to keep track of which server they are connecting to, you can ignore this for now. } // Function to send an arbitrarily long message to the server void send_message(int client_socket, const char *message) { // TODO: Implement message sending in chunks of 150 bytes } // Function to close the client socket void close_client_socket(int client_socket) { // TODO: Implement closing the client socket } Rubric: 1. **Using UDP (10 points)**: Both client and server correctly implement UDP (SOCK_DGRAM). 2. **Fragmenting on the Client (10 points)**: Client properly splits messages longer than 150 bytes into 150-byte packets. 3. **Reassembling on the Server (10 points)**: Server accurately reassembles fragmented packets received from the client. 4. **Oversized Packets (10 points)**: Oversized packets are correctly handled, either rejected or not sent by the client. 5. **Handling Very Large Message (10 points)**: Very large messages are handled properly, fragmented, transmitted, and reassembled without issues. 6. **Handling Empty Message (10 points)**: Empty messages are handled gracefully without causing errors in transmission. 7. **Partial Packet Handling (10 points)**: The final partial packet (less than 150 bytes) is handled correctly by both client and server. 8. **Server Binding (10 points)**: Server successfully binds to the specified address and port. 9. **Server Accept (10 points)**: Server correctly accepts and handles incoming connections from the client. 10. **General code formatting and logging (10 points)** Weeks 7-8: CPU Cycle Optimization with Limited Processing Power #Problem: A power outage forces the colony to run its operations on a backup CPU with limited processing power. Teams must optimize the CPU\u0026rsquo;s fetch-and-execute cycle to ensure all critical systems remain operational. Task: Simulate a CPU fetch-and-execute cycle in C, optimizing instruction execution under cycle constraints (e.g., 100 cycles). Resource Constraints: Limited CPU cycles available; teams must optimize the order and execution of instructions to minimize cycle usage while maintaining functionality. Outcome: Students learn CPU optimization techniques and develop the ability to maximize efficiency under processing constraints. Weeks 9-10: Storage System Designer with Limited Access #Problem: The colony\u0026rsquo;s data center faces a critical storage shortage. Teams must redesign their storage systems to prioritize essential data and optimize read/write operations under constrained access conditions. Task: Implement a storage management system in C that simulates limited read/write operations and prioritizes critical data. Resource Constraints: Limited storage operations (e.g., 50 read/write operations); teams must prioritize essential data and optimize access patterns to reduce latency. Outcome: Teams gain experience in managing storage resources efficiently, ensuring optimal data retrieval and storage under constrained conditions. Weeks 11-12: Dynamic Memory Manager with Limited Resources #Problem: The colony\u0026rsquo;s mainframe is overloaded with emergency data logs due to a storm. The system needs a dynamic memory manager that can handle frequent allocation and deallocation without running out of memory. Task: Develop a memory manager in C that allocates and deallocates memory dynamically, ensuring no memory leaks within a restricted memory limit (e.g., 512 bytes). Resource Constraints: Limited memory space and frequent allocation/deallocation requests; the memory manager must efficiently manage memory and prevent fragmentation. Outcome: Teams enhance their skills in dynamic memory management, learning to handle fluctuating data loads and prevent memory leaks in resource-constrained environments. Weeks 13-14: Secure Communication with Limited Resources #Problem: A rival faction attempts to intercept colony communications. Teams must enhance their network security protocols to encrypt data and authenticate users while operating under limited processing and memory resources. Task: Enhance the client-server application to use efficient encryption and authentication techniques in C, balancing security with available resources. Resource Constraints: Limited processing power and memory; teams must implement security measures that protect data integrity and confidentiality without overloading the system. Outcome: Students learn to balance security and performance, optimizing cryptographic algorithms under resource constraints to ensure secure communication. Success Criteria: #To succeed, each team must complete the bi-weekly challenges by writing efficient and effective C/C++ programs. Performance is evaluated based on the correctness of their solutions, the efficiency of resource usage, and the ability to optimize under constraints. The team with the most points at the end of the 10-week period (spanning 14 weeks) is awarded the title of \u0026ldquo;Ultimate Systems Champions\u0026rdquo;.
`}),e.add({id:2,href:"/F24-CSC2770/docs/prologue/lab1/",title:"Lab1",description:`Instructions #Note: The following guide provides step-by-step instructions for creating and configuring virtual machines (VMs) on the Google Cloud Platform (GCP). Subsequently, the guide outlines the process of establishing network connectivity between these VMs using the “ping” command. This exercise aims to provide students with a practical understanding of cloud-based virtualization, network configuration, and basic connectivity testing. This lab is ungraded.
Lab Objectives #Creating two virtual machines on Google Cloud.`,content:`Instructions #Note: The following guide provides step-by-step instructions for creating and configuring virtual machines (VMs) on the Google Cloud Platform (GCP). Subsequently, the guide outlines the process of establishing network connectivity between these VMs using the “ping” command. This exercise aims to provide students with a practical understanding of cloud-based virtualization, network configuration, and basic connectivity testing. This lab is ungraded.
Lab Objectives #Creating two virtual machines on Google Cloud. Configuring network settings for the VMs. Testing network connectivity between the VMs using the “ping” command. Prerequisites #An active Google Cloud account. - You can create an account that comes with sign-up credits. The current sign-up credit is \$300 for 90 days. We will distribute additional credits as they become available. Basic familiarity with command-line interfaces and networking concepts. We will provide coupon codes once we hear from Google. Step 1: Creating Virtual Machines #Log in to your Google Cloud Console. Navigate to the Compute Engine section and click on “VM instances.” Click the “Create Instance” button to create your first VM. Choose a suitable name and region for your VM. Select a machine type based on your requirements. Configure boot disk settings. Configure firewall rules to allow ICMP (ping) traffic. Step 2: Configuring Network Settings #Once both VMs are created, take note of their internal and external IP addresses. To enable communication between the VMs, configure their firewall settings to allow ICMP traffic. In the “Firewall” section, establish a new firewall rule. Provide a name and description for the rule. Set the target tags to match the VMs you’ve created. Define the source IP ranges as the internal IP address of the other VM. Allow ICMP protocol Step 3: Testing Connectivity #Access one of the VMs through SSH using a terminal or command prompt. Utilize the “ping” command to examine connectivity to the other VM. `}),e.add({id:3,href:"/F24-CSC2770/docs/prologue/",title:"Prologue",description:"Prologue Doks.",content:""}),e.add({id:4,href:"/F24-CSC2770/docs/",title:"Docs",description:"Docs Doks.",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()